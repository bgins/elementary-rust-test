import events from 'events';

declare abstract class EmptyList {
    protected opaque: any;
}
declare abstract class Cons<T> {
    protected opaque: T;
}
declare type list<T> = Cons<T> | EmptyList;

declare abstract class props {
    protected opaque: any;
}
declare type t = {
    readonly symbol: string;
    readonly hash: number;
    readonly kind: string;
    readonly props: props;
    readonly children: list<t>;
};

declare type ElemNode = t | number;

declare function resolve(n: ElemNode): t;
declare function isNode(n: unknown): n is t;
declare function createNode(kind: string, props: any, children: Array<ElemNode>): t;

declare abstract class RenderDelegate_t {
    protected opaque: any;
}
declare const renderWithDelegate: (delegate: RenderDelegate_t, graphs: t[]) => void;
declare const stepGarbageCollector: (delegate: RenderDelegate_t) => void;

declare type ConstNodeProps = {
    key?: string;
    value: number;
};
declare function constant(props: ConstNodeProps): t;

declare type IdentityNodeProps = {
    key?: string;
    channel?: number;
};
declare function identity(x: ElemNode): t;
declare function identity(props: IdentityNodeProps): t;
declare function identity(props: IdentityNodeProps, x: ElemNode): t;

declare type EventListener<E> = (event: E) => void;
declare type Events = {
    "error": Error;
    "fft": {
        source?: string;
        data: {
            real: Float32Array;
            imag: Float32Array;
        };
    };
    "load": void;
    "meter": {
        source?: string;
        min: number;
        max: number;
    };
    "scope": {
        source?: string;
        data: Float32Array[];
    };
    "snapshot": {
        source?: string;
        data: number;
    };
};
declare interface EventEmitter {
    addListener<K extends keyof Events>(eventName: K, listener: EventListener<Events[K]>): this;
    listenerCount<K extends keyof Events>(eventName: K, listener?: EventListener<Events[K]>): number;
    listeners<K extends keyof Events>(eventName: K): Function[];
    off<K extends keyof Events>(eventName: K, listener: EventListener<Events[K]>): this;
    on<K extends keyof Events>(eventName: K, listener: EventListener<Events[K]>): this;
    once<K extends keyof Events>(eventName: K, listener: EventListener<Events[K]>): this;
    prependListener<K extends keyof Events>(eventName: K, listener: EventListener<Events[K]>): this;
    prependOnceListener<K extends keyof Events>(eventName: K, listener: EventListener<Events[K]>): this;
    removeAllListeners<K extends keyof Events>(eventName?: K): this;
    removeListener<K extends keyof Events>(eventName: K, listener: EventListener<Events[K]>): this;
    rawListeners<K extends keyof Events>(eventName: K): Function[];
}
declare class EventEmitter extends events.EventEmitter {
}

declare const stdlib: {
    const: typeof constant;
    in: typeof identity;
    ms2samps(t: ElemNode): t;
    tau2pole(t: ElemNode): t;
    db2gain(db: ElemNode): t;
    gain2db(gain: ElemNode): t;
    select(g: ElemNode, a: ElemNode, b: ElemNode): t;
    hann(t: ElemNode): t;
    train(rate: ElemNode): t;
    train(props: {
        key?: string;
    }, rate: ElemNode): t;
    cycle(rate: ElemNode): t;
    cycle(props: {
        key?: string;
    }, rate: ElemNode): t;
    saw(rate: ElemNode): t;
    saw(props: {
        key?: string;
    }, rate: ElemNode): t;
    square(rate: ElemNode): t;
    square(props: {
        key?: string;
    }, rate: ElemNode): t;
    triangle(rate: ElemNode): t;
    triangle(props: {
        key?: string;
    }, rate: ElemNode): t;
    blepsaw(rate: ElemNode): t;
    blepsaw(props: {
        key?: string;
    }, rate: ElemNode): t;
    blepsquare(rate: ElemNode): t;
    blepsquare(props: {
        key?: string;
    }, rate: ElemNode): t;
    bleptriangle(rate: ElemNode): t;
    bleptriangle(props: {
        key?: string;
    }, rate: ElemNode): t;
    noise(): t;
    noise(props: {
        key?: string;
        seed?: number;
    }): t;
    pinknoise(): t;
    pinknoise(props: {
        key?: string;
        seed?: number;
    }): t;
    identity(x: ElemNode): t;
    identity(props: {
        key?: string;
        channel?: number;
    }): t;
    identity(props: {
        key?: string;
        channel?: number;
    }, x: ElemNode): t;
    sin(x: ElemNode): t;
    sin(props: {
        key?: string;
    }, x: ElemNode): t;
    cos(x: ElemNode): t;
    cos(props: {
        key?: string;
    }, x: ElemNode): t;
    tan(x: ElemNode): t;
    tan(props: {
        key?: string;
    }, x: ElemNode): t;
    tanh(x: ElemNode): t;
    tanh(props: {
        key?: string;
    }, x: ElemNode): t;
    asinh(x: ElemNode): t;
    asinh(props: {
        key?: string;
    }, x: ElemNode): t;
    ln(x: ElemNode): t;
    ln(props: {
        key?: string;
    }, x: ElemNode): t;
    log(x: ElemNode): t;
    log(props: {
        key?: string;
    }, x: ElemNode): t;
    log2(x: ElemNode): t;
    log2(props: {
        key?: string;
    }, x: ElemNode): t;
    ceil(x: ElemNode): t;
    ceil(props: {
        key?: string;
    }, x: ElemNode): t;
    floor(x: ElemNode): t;
    floor(props: {
        key?: string;
    }, x: ElemNode): t;
    round(x: ElemNode): t;
    round(props: {
        key?: string;
    }, x: ElemNode): t;
    sqrt(x: ElemNode): t;
    sqrt(props: {
        key?: string;
    }, x: ElemNode): t;
    exp(x: ElemNode): t;
    exp(props: {
        key?: string;
    }, x: ElemNode): t;
    abs(x: ElemNode): t;
    abs(props: {
        key?: string;
    }, x: ElemNode): t;
    le(a: ElemNode, b: ElemNode): t;
    le(props: {
        key?: string;
    }, a: ElemNode, b: ElemNode): t;
    leq(a: ElemNode, b: ElemNode): t;
    leq(props: {
        key?: string;
    }, a: ElemNode, b: ElemNode): t;
    ge(a: ElemNode, b: ElemNode): t;
    ge(props: {
        key?: string;
    }, a: ElemNode, b: ElemNode): t;
    geq(a: ElemNode, b: ElemNode): t;
    geq(props: {
        key?: string;
    }, a: ElemNode, b: ElemNode): t;
    pow(a: ElemNode, b: ElemNode): t;
    pow(props: {
        key?: string;
    }, a: ElemNode, b: ElemNode): t;
    eq(a: ElemNode, b: ElemNode): t;
    eq(props: {
        key?: string;
    }, a: ElemNode, b: ElemNode): t;
    and(a: ElemNode, b: ElemNode): t;
    and(props: {
        key?: string;
    }, a: ElemNode, b: ElemNode): t;
    or(a: ElemNode, b: ElemNode): t;
    or(props: {
        key?: string;
    }, a: ElemNode, b: ElemNode): t;
    add(...args: ElemNode[]): t;
    add(props: {
        key?: string;
    }, ...args: ElemNode[]): t;
    sub(...args: ElemNode[]): t;
    sub(props: {
        key?: string;
    }, ...args: ElemNode[]): t;
    mul(...args: ElemNode[]): t;
    mul(props: {
        key?: string;
    }, ...args: ElemNode[]): t;
    div(...args: ElemNode[]): t;
    div(props: {
        key?: string;
    }, ...args: ElemNode[]): t;
    mod(...args: ElemNode[]): t;
    mod(props: {
        key?: string;
    }, ...args: ElemNode[]): t;
    min(...args: ElemNode[]): t;
    min(props: {
        key?: string;
    }, ...args: ElemNode[]): t;
    max(...args: ElemNode[]): t;
    max(props: {
        key?: string;
    }, ...args: ElemNode[]): t;
    smooth(p: ElemNode, x: ElemNode): t;
    smooth(props: {
        key?: string;
    }, p: ElemNode, x: ElemNode): t;
    sm(x: ElemNode): t;
    sm(props: {
        key?: string;
    }, x: ElemNode): t;
    zero(b0: ElemNode, b1: ElemNode, x: ElemNode): t;
    zero(props: {
        key?: string;
    }, b0: ElemNode, b1: ElemNode, x: ElemNode): t;
    dcblock(x: ElemNode): t;
    dcblock(props: {
        key?: string;
    }, x: ElemNode): t;
    df11(b0: ElemNode, b1: ElemNode, a1: ElemNode, x: ElemNode): t;
    df11(props: {
        key?: string;
    }, b0: ElemNode, b1: ElemNode, a1: ElemNode, x: ElemNode): t;
    lowpass(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    lowpass(props: {
        key?: string;
    }, fc: ElemNode, q: ElemNode, x: ElemNode): t;
    highpass(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    highpass(props: {
        key?: string;
    }, fc: ElemNode, q: ElemNode, x: ElemNode): t;
    bandpass(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    bandpass(props: {
        key?: string;
    }, fc: ElemNode, q: ElemNode, x: ElemNode): t;
    notch(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    notch(props: {
        key?: string;
    }, fc: ElemNode, q: ElemNode, x: ElemNode): t;
    allpass(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    allpass(props: {
        key?: string;
    }, fc: ElemNode, q: ElemNode, x: ElemNode): t;
    peak(fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    peak(props: {
        key?: string;
    }, fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    lowshelf(fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    lowshelf(props: {
        key?: string;
    }, fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    highshelf(fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    highshelf(props: {
        key?: string;
    }, fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    pink(x: ElemNode): t;
    pink(props: {
        key?: string;
    }, x: ElemNode): t;
    adsr(attackSec: ElemNode, decaySec: ElemNode, sustain: ElemNode, releaseSec: ElemNode, gate: ElemNode): t;
    adsr(props: {
        key?: string;
    }, attackSec: ElemNode, decaySec: ElemNode, sustain: ElemNode, releaseSec: ElemNode, gate: ElemNode): t;
    compress(attackMs: ElemNode, releaseMs: ElemNode, threshold: ElemNode, ratio: ElemNode, sidechain: ElemNode, xn: ElemNode): t;
    skcompress(attackMs: ElemNode, releaseMs: ElemNode, threshold: ElemNode, ratio: ElemNode, kneeWidth: ElemNode, sidechain: ElemNode, xn: ElemNode): t;
    constant(props: {
        key?: string;
        value: number;
    }): t;
    sr(): t;
    time(): t;
    counter(gate: ElemNode): t;
    counter(props: {
        key?: string;
    }, gate: ElemNode): t;
    accum(xn: ElemNode, reset: ElemNode): t;
    accum(props: {
        key?: string;
    }, xn: ElemNode, reset: ElemNode): t;
    phasor(rate: ElemNode): t;
    phasor(props: {
        key?: string;
    }, rate: ElemNode): t;
    syncphasor(rate: ElemNode, reset: ElemNode): t;
    syncphasor(props: {
        key?: string;
    }, rate: ElemNode, reset: ElemNode): t;
    latch(t: ElemNode, x: ElemNode): t;
    latch(props: {
        key?: string;
    }, t: ElemNode, x: ElemNode): t;
    maxhold(x: ElemNode, reset: ElemNode): t;
    maxhold(props: {
        key?: string;
        hold?: number;
    }, x: ElemNode, reset: ElemNode): t;
    once(x: ElemNode): t;
    once(props: {
        key?: string;
        arm?: boolean;
    }, x: ElemNode): t;
    rand(): t;
    rand(props: {
        key?: string;
        seed?: number;
    }): t;
    metro(): t;
    metro(props: {
        key?: string;
        interval?: number;
    }): t;
    sample(props: {
        key?: string;
        path?: string;
        mode?: string;
        startOffset?: number;
        stopOffset?: number;
    }, trigger: ElemNode, rate: ElemNode): t;
    table(props: {
        key?: string;
        path?: string;
    }, t: ElemNode): t;
    convolve(props: {
        key?: string;
        path?: string;
    }, x: ElemNode): t;
    seq(props: {
        key?: string;
        seq?: number[];
        offset?: number;
        hold?: boolean;
        loop?: boolean;
    }, trigger: ElemNode, reset: ElemNode): t;
    seq2(props: {
        key?: string;
        seq?: number[];
        offset?: number;
        hold?: boolean;
        loop?: boolean;
    }, trigger: ElemNode, reset: ElemNode): t;
    sparseq(props: {
        key?: string;
        seq?: {
            value: number;
            tickTime: number;
        }[];
        offset?: number;
        loop?: boolean | number[];
        resetOnLoop?: boolean;
        interpolate?: number;
        tickInterval?: number;
    }, trigger: ElemNode, reset: ElemNode): t;
    sparseq2(props: {
        key?: string;
        seq?: {
            value: number;
            time: number;
        }[];
    }, time: ElemNode): t;
    sampleseq(props: {
        key?: string;
        seq?: {
            value: number;
            time: number;
        }[];
        duration: number;
        path: string;
    }, time: ElemNode): t;
    pole(p: ElemNode, x: ElemNode): t;
    pole(props: {
        key?: string;
    }, p: ElemNode, x: ElemNode): t;
    env(atkPole: ElemNode, relPole: ElemNode, x: ElemNode): t;
    env(props: {
        key?: string;
    }, atkPole: ElemNode, relPole: ElemNode, x: ElemNode): t;
    z(x: ElemNode): t;
    z(props: {
        key?: string;
    }, x: ElemNode): t;
    delay(props: {
        key?: string;
        size: number;
    }, len: ElemNode, fb: ElemNode, x: ElemNode): t;
    sdelay(props: {
        key?: string;
        size: number;
    }, x: ElemNode): t;
    prewarp(fc: ElemNode): t;
    mm1p(fc: ElemNode, x: ElemNode): t;
    mm1p(props: {
        key?: string;
        mode?: string;
    }, fc: ElemNode, x: ElemNode): t;
    svf(fc: ElemNode, q: ElemNode, x: ElemNode): t;
    svf(props: {
        key?: string;
        mode?: string;
    }, fc: ElemNode, q: ElemNode, x: ElemNode): t;
    svfshelf(fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    svfshelf(props: {
        key?: string;
        mode?: string;
    }, fc: ElemNode, q: ElemNode, gainDecibels: ElemNode, x: ElemNode): t;
    biquad(b0: ElemNode, b1: ElemNode, b2: ElemNode, a1: ElemNode, a2: ElemNode, x: ElemNode): t;
    biquad(props: {
        key?: string;
    }, b0: ElemNode, b1: ElemNode, b2: ElemNode, a1: ElemNode, a2: ElemNode, x: ElemNode): t;
    tapIn(props: {
        name: string;
    }): t;
    tapOut(props: {
        name: string;
    }, x: ElemNode): t;
    meter(x: ElemNode): t;
    meter(props: {
        key?: string;
        name?: string;
    }, x: ElemNode): t;
    snapshot(trigger: ElemNode, x: ElemNode): t;
    snapshot(props: {
        key?: string;
        name?: string;
    }, trigger: ElemNode, x: ElemNode): t;
    scope(...args: ElemNode[]): t;
    scope(props: {
        key?: string;
        name?: string;
        size?: number;
        channels?: number;
    }, ...args: ElemNode[]): t;
    fft(x: ElemNode): t;
    fft(props: {
        key?: string;
        name?: string;
        size?: number;
    }, x: ElemNode): t;
    capture(g: ElemNode, x: ElemNode): t;
    capture(props: {
        key?: string;
        size?: number;
    }, g: ElemNode, x: ElemNode): t;
};
declare class Delegate {
    nodesAdded: number;
    nodesRemoved: number;
    edgesAdded: number;
    propsWritten: number;
    nodeMap: Map<number, any>;
    private currentActiveRoots;
    private batch;
    constructor();
    clear(): void;
    getNodeMap(): Map<number, any>;
    getTerminalGeneration(): number;
    createNode(hash: any, type: any): void;
    deleteNode(hash: any): void;
    appendChild(parentHash: any, childHash: any): void;
    setProperty(hash: any, key: any, value: any): void;
    activateRoots(roots: any): void;
    commitUpdates(): void;
    getPackedInstructions(): any[];
}
declare class Renderer {
    private _delegate;
    private _sendMessage;
    private _nextRefId;
    constructor(sendMessage: any);
    createRef(kind: any, props: any, children: any): (t | ((newProps: any) => void))[];
    render(...args: any[]): {
        nodesAdded: number;
        edgesAdded: number;
        propsWritten: number;
        elapsedTimeMs: number;
    };
}

export { Delegate, ElemNode, EventEmitter, t as NodeRepr_t, Renderer, createNode, stdlib as el, isNode, renderWithDelegate, resolve, stdlib, stepGarbageCollector };
